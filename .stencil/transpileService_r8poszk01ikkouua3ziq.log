{"moduleFile":{"sourceFilePath":"/home/chris/wallet/src/components/wallet/methods/makePayment.ts","jsFilePath":"/home/chris/wallet/src/components/wallet/methods/makePayment.js","cmps":[],"coreRuntimeApis":[],"collectionName":null,"dtsFilePath":null,"excludeFromCollection":false,"externalImports":["@services/error","@tinyanvil/sjcl","lodash-es","stellar-sdk"],"hasVdomAttribute":false,"hasVdomXlink":false,"hasVdomClass":false,"hasVdomFunctional":false,"hasVdomKey":false,"hasVdomListener":false,"hasVdomPropOrAttr":false,"hasVdomRef":false,"hasVdomRender":false,"hasVdomStyle":false,"hasVdomText":false,"htmlAttrNames":[],"htmlTagNames":[],"isCollectionDependency":false,"isLegacy":false,"localImports":[],"originalCollectionComponentPath":null,"originalImports":["@tinyanvil/sjcl","stellar-sdk","lodash-es","@services/error"],"potentialCmpRefs":[],"staticSourceFile":null,"staticSourceFileText":""},"jsText":"import sjcl from \"@tinyanvil/sjcl\";\r\nimport { Keypair, Account, TransactionBuilder, BASE_FEE, Networks, Operation, Asset, } from \"stellar-sdk\";\r\nimport { has as loHas } from \"lodash-es\";\r\nimport { handleError } from \"@services/error\";\r\nexport default async function makePayment(e) {\r\n    try {\r\n        e.preventDefault();\r\n        // change to add new trustline\r\n        let instructions = await this.setPrompt(\"{Amount} {Asset} {Destination}\");\r\n        instructions = instructions.split(\" \");\r\n        if (!/xlm/gi.test(instructions[1]))\r\n            instructions[3] = await this.setPrompt(`Who issues the ${instructions[1]} asset?`, \"Enter ME to refer to yourself\");\r\n        // let instructions = await this.setPrompt(\"{Amount} {Destination}\");\r\n        // instructions = instructions.split(\" \");\r\n        // end of change to add new trustline\r\n        const pincode = await this.setPrompt(\"Enter your keystore pincode\");\r\n        if (!instructions || !pincode)\r\n            return;\r\n        const keypair = Keypair.fromSecret(sjcl.decrypt(pincode, this.account.keystore));\r\n        // change added here for trustline \r\n        // \r\n        this.error = null;\r\n        this.loading = Object.assign(Object.assign({}, this.loading), { pay: true });\r\n        await this.server\r\n            .accounts()\r\n            .accountId(keypair.publicKey())\r\n            .call()\r\n            .then(({ sequence }) => {\r\n            const account = new Account(keypair.publicKey(), sequence);\r\n            const transaction = new TransactionBuilder(account, {\r\n                fee: BASE_FEE,\r\n                networkPassphrase: Networks.TESTNET,\r\n            })\r\n                .addOperation(Operation.payment({\r\n                destination: instructions[1],\r\n                asset: Asset.native(),\r\n                amount: instructions[0],\r\n            }))\r\n                .setTimeout(0)\r\n                .build();\r\n            transaction.sign(keypair);\r\n            return this.server.submitTransaction(transaction).catch((err) => {\r\n                if (\r\n                // Paying an account which doesn't exist, create it instead\r\n                loHas(err, \"response.data.extras.result_codes.operations\") &&\r\n                    err.response.data.status === 400 &&\r\n                    err.response.data.extras.result_codes.operations.indexOf(\"op_no_destination\") !== -1) {\r\n                    const transaction = new TransactionBuilder(account, {\r\n                        fee: BASE_FEE,\r\n                        networkPassphrase: Networks.TESTNET,\r\n                    })\r\n                        .addOperation(Operation.createAccount({\r\n                        destination: instructions[1],\r\n                        startingBalance: instructions[0],\r\n                    }))\r\n                        .setTimeout(0)\r\n                        .build();\r\n                    transaction.sign(keypair);\r\n                    return this.server.submitTransaction(transaction);\r\n                }\r\n                else\r\n                    throw err;\r\n            });\r\n        })\r\n            .then((res) => console.log(res))\r\n            .finally(() => {\r\n            this.loading = Object.assign(Object.assign({}, this.loading), { pay: false });\r\n            this.updateAccount();\r\n        });\r\n    }\r\n    catch (err) {\r\n        this.error = handleError(err);\r\n    }\r\n}\r\n"}